#pragma once

#include <iostream>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
// Include glm constants
#include <glm/gtc/constants.hpp>
#include <stb_image_write.h>

class Noise {
public:

	enum class Interpolation {
		Linear,
		Cosine,
		Smoothstep,
		Smootherstep,
		Cubic
	};

	float hash(glm::vec2 uv) {
		return glm::fract(glm::sin(glm::dot(uv, glm::vec2(12.9898f, 78.233f))) * 43758.5453f);
	}

	Noise (int seed = 0) {
		std::srand(0);
		for (int i = 0; i < tableSize; i++) {
			for (int j = 0; j < tableSize; j++) {
				table[i][j] = std::rand() / float(RAND_MAX);
			}
		}
	}


	float cubicInterpolate(float a, float b, float c, float d, float f) {
		// n=x(x(x(−a+b−c+d)+2a−2b+c−d)−a+c)+b
		return f * (f * (f * (-a + b - c + d) + (2.0f * a) - 2.0f * b + c - d) - a + c) + b;
	}


	/**
	 * @brief Evaluate the noise at a given point using bilinear interpolation
	 * @param uv The 2D point at which to evaluate the noise.
	 * @param smooth The interpolation method to use.
	 * @return The evaluated noise value.
	 */
	float evalBilerp(glm::vec2 uv, Interpolation smooth = Interpolation::Linear) {

//		if (uv.x < 0 || uv.x > tableSize - 1 || uv.y < 0 || uv.y > tableSize - 1) {
//			std::cerr << "UV out of bounds" << std::endl;
//			return 0;
//		}

		int xMin = glm::floor(uv.x);
		int yMin = glm::floor(uv.y);

		// Wrap around on edges
		int xMax = (xMin + 1) % tableSize;
		int yMax = (yMin + 1) % tableSize;

		float tl = table[xMin][yMin];
		float bl = table[xMax][yMin];
		float tr = table[xMin][yMax];
		float br = table[xMax][yMax];

		// Interpolate
		glm::vec2 f = glm::fract(uv);

		switch (smooth) {
			case Interpolation::Linear:
				break;
			case Interpolation::Cosine:
				f = (glm::vec2(1.0f, 1.0f) - glm::cos(f * glm::pi<float>())) * 0.5f;
				break;
			case Interpolation::Smoothstep:
				f = f * f * (3.0f - 2.0f * f);
				break;
			case Interpolation::Smootherstep:
				f = f * f * f * (f * (f * 6.0f - 15.0f) + 10.0f);
				break;
			case Interpolation::Cubic:
				float xSamples[4];

				for(int i = 0; i < 4; i++) {
					glm::ivec2 first  = {((xMin - 1) % tableSize + tableSize) % tableSize, ((yMin - 1 + i) % tableSize + tableSize) % tableSize};
					glm::ivec2 second = {((xMin + 0) % tableSize + tableSize) % tableSize, ((yMin - 1 + i) % tableSize + tableSize) % tableSize};
					glm::ivec2 third  = {((xMin + 1) % tableSize + tableSize) % tableSize, ((yMin - 1 + i) % tableSize + tableSize) % tableSize};
					glm::ivec2 fourth = {((xMin + 2) % tableSize + tableSize) % tableSize, ((yMin - 1 + i) % tableSize + tableSize) % tableSize};

					xSamples[i] = cubicInterpolate(
							table[first.x][first.y],
							table[second.x][second.y],
							table[third.x][third.y],
							table[fourth.x][fourth.y],
							f.x);
				}
				return glm::clamp(cubicInterpolate(xSamples[0], xSamples[1], xSamples[2], xSamples[3], f.y), 0.0f, 1.0f);
				break;
			default:
				break;
		}

		// Bilerp between the four corners
		float left = glm::mix(tl, bl, f.x);
		float right = glm::mix(tr, br, f.x);
		return glm::mix(left, right, f.y);
	}

	/**
	 * @brief Generates a noise map with a given offset.
	 * @param offset The offset to apply to the noise map.
	 *
	 * @details The noise map is generated by evaluating the noise
	 * 			at each point in the map using bilinear interpolation.
	 */
	void generate(glm::vec2 offset = glm::vec2(0.0f)) {

		int stepsPerUnit = resolution / tableSize;

		for (int row = 0; row < resolution; row++) {
			for (int col = 0; col < resolution; col++) {
				float x = col / float(stepsPerUnit) + offset.x;
				float y = row / float(stepsPerUnit) + offset.y;
				noiseMap[row][col] = evalBilerp(glm::vec2(x, y), Interpolation::Cubic);
			}
		}
	}

	void output() {

		for (int row = 0; row < resolution; row++) {
			for (int col = 0; col < resolution; col++) {
				bitMap[row][col] = noiseMap[row][col] * 255;
			}
		}

		if(stbi_write_bmp("noise.bmp", Noise::resolution, Noise::resolution, 1, bitMap) == 0) {
			std::cerr << "Failed to write noise to file" << std::endl;
		} else {
			std::cout << "Wrote noise to file" << std::endl;
		}

	}

	// Size of the table used to generate the noise.
	static const int tableSize = 32;

	// Width and height of the noise map.
	// I.e. If resolution is 64 and table size is 16, there will be
	// four steps per random value in the table.
	static const int resolution = 256;

	// The generated noise map. The entire noise map interpolates across
	// the table of random values.
	float noiseMap[resolution][resolution]{};

	// The bitmap representation of the noise map used for output files.
	uint8_t bitMap[resolution][resolution]{};

	// Table of random values used to generate the noise.
	float table[tableSize][tableSize]{};

};
